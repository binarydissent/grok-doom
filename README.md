# Doom Dialogue & Xephyr Setup

!info!: Doom is an 8‑bit color game—you can’t run it on a modern monitor because current displays typically operate at high color depths. To experience Doom in its authentic, gritty 8‑bit mode, we emulate an 8‑bit monitor using Xephyr. This version of Doom comes with unhinged, over‑the‑top NPC dialogue generated by Grok — a LLM that produces raw, brutal, and unpredictable lines true to the DOOM universe, rated R18+.

This repository includes:
- A refactored Python dialogue server that leverages Grok to generate R18, unhinged dialogue for Doom NPCs.
- Detailed instructions for setting up Xephyr and running the Linux Doom 1.10 port, so you can relive the classic 8‑bit experience on modern hardware.


## Requirements

- **Linux Doom 1.10**: The Doom source port (located in the `linuxdoom-1.10` directory).
- **Xephyr**: A nested X server to emulate an 8-bit color display.
- **Python 3**: To run the dialogue server.
- **Python dependencies**: `python-dotenv`, `openai` (or your LLM client library)

## Installation

### Install Xephyr

- **Debian/Ubuntu**:
  ```bash
  sudo apt install xserver-xephyr
  ```
- **Arch Linux**:
  ```bash
  sudo pacman -S xserver-xephyr
  ```

### Install Python Dependencies

Create a virtual environment (optional) and install the required packages:
```bash
python3 -m venv venv
source venv/bin/activate
pip install python-dotenv openai
```

Make sure your `.env` file is in the root directory with your environment variables:
```
LLM=XAI
MODEL=grok-2-latest
XAI_API_KEY=your_xai_api_key
```

## Running the Emulated 8-bit Monitor with Xephyr

1. **Start Xephyr**  
   Run Xephyr to emulate a display with 640x480 resolution and 8-bit color depth. For example:
   ```bash
   sudo Xephyr :2 -ac -screen 640x480x8
   ```
   This starts a nested X server on display `:2`.

2. **Launch Doom 1.10**  
   Open a terminal and change to the `linuxdoom-1.10` directory:
   ```bash
   cd linuxdoom-1.10
   ```
   Set the `DISPLAY` environment variable to `:2` so that Doom uses the Xephyr window:
   ```bash
   export DISPLAY=:2
   ```
   Then, run Doom (adjust the path/arguments as needed):
   ```bash
   ./linux/linuxxdoom -2
   ```
   The `-2` argument is used here as an example flag for Doom—ensure that it matches your mod’s configuration if necessary.

## Running the Dialogue Server

This Python script listens for dialogue context from Doom (via FIFO files) and returns generated dialogue. To run it:

1. **Ensure the FIFO files are set up correctly:**  
   The script uses the following FIFOs (by default):
   - Request FIFO: `/tmp/doom_dialogue_req`
   - Response FIFO: `/tmp/doom_dialogue_res`

   These are created automatically when the script starts.

2. **Run the Python Server:**  
   In a separate terminal (or screen), run:
   ```bash
   python3 doom_dialogue_server.py
   ```
   (Make sure the environment variables are loaded via your `.env` file.)  
   The server will listen for requests on the FIFO, generate dialogue using your chosen LLM, format it (wrapping at 80 characters per line), and write it to the response FIFO.

## Summary

- **Xephyr Setup:**  
  Install Xephyr, run it with 8-bit color on display `:2`, and launch Doom on that display.
- **Dialogue Server:**  
  Run the provided Python script to serve NPC dialogue. It reads dialogue context from `/tmp/doom_dialogue_req` and writes responses to `/tmp/doom_dialogue_res`.

Feel free to modify any of these settings or helper functions in the Python script to better fit your Doom mod’s needs.



---------

(DOOM Source code fixed)

Here it is, at long last. The DOOM source code is released for your non-profit use. You still need real DOOM data to work with this code. If you don't actually own a real copy of one of the DOOMs, you should still be able to find them at software stores.

Many thanks to Bernd Kreimeier for taking the time to clean up the project and make sure that it actually works. Projects tends to rot if you leave it alone for a few years, and it takes effort for someone to deal with it again.

The bad news: this code only compiles and runs on linux. We couldn't release the dos code because of a copyrighted sound library we used (wow, was that a mistake -- I write my own sound code now), and I honestly don't even know what happened to the port that microsoft did to windows.

Still, the code is quite portable, and it should be straightforward to bring it up on just about any platform.

I wrote this code a long, long time ago, and there are plenty of things that seem downright silly in retrospect (using polar coordinates for clipping comes to mind), but overall it should still be a usefull base to experiment and build on.

The basic rendering concept -- horizontal and vertical lines of constant Z with fixed light shading per band was dead-on, but the implementation could be improved dramatically from the original code if it were revisited. The way the rendering proceded from walls to floors to sprites could be collapsed into a single front-to-back walk of the bsp tree to collect information, then draw all the contents of a subsector on the way back up the tree. It requires treating floors and ceilings as polygons, rather than just the gaps between walls, and it requires clipping sprite billboards into subsector fragments, but it would be The Right Thing.

The movement and line of sight checking against the lines is one of the bigger misses that I look back on. It is messy code that had some failure cases, and there was a vastly simpler (and faster) solution sitting in front of my face. I used the BSP tree for rendering things, but I didn't realize at the time that it could also be used for environment testing. Replacing the line of sight test with a bsp line clip would be pretty easy. Sweeping volumes for movement gets a bit tougher, and touches on many of the challenges faced in quake / quake2 with edge bevels on polyhedrons.

Some project ideas:

Port it to your favorite operating system.

Add some rendering features -- transparency, look up / down, slopes, etc.

Add some game features -- weapons, jumping, ducking, flying, etc.

Create a packet server based internet game.

Create a client / server based internet game.

Do a 3D accelerated version. On modern hardware (fast pentium + 3DFX) you probably wouldn't even need to be clever -- you could just draw the entire level and get reasonable speed. With a touch of effort, it should easily lock at 60 fps (well, there are some issues with DOOM's 35 hz timebase...). The biggest issues would probably be the non-power of two texture sizes and the walls composed of multiple textures.

I don't have a real good guess at how many people are going to be playing with this, but if significant projects are undertaken, it would be cool to see a level of community cooperation. I know that most early projects are going to be rough hacks done in isolation, but I would be very pleased to see a coordinated 'net release of an improved, backwards compatable version of DOOM on multiple platforms next year.

Have fun.

John Carmack 12-23-97

Credits: https://github.com/id-Software/DOOM
